import{_ as a,p as l,q as i,a1 as n}from"./framework-96b046e1.js";const e="/assets/image-20230604153726061-f82071bf.png",s={},t=n(`<h1 id="javase" tabindex="-1"><a class="header-anchor" href="#javase" aria-hidden="true">#</a> JavaSE</h1><h3 id="和equals方法之前的区别" tabindex="-1"><a class="header-anchor" href="#和equals方法之前的区别" aria-hidden="true">#</a> ==和equals⽅法之前的区别?</h3><ol><li><p>==：基本数据类型对比是变量值，引⽤类型对比是是堆中内存对象的地址。</p></li><li><p>equals：object中默认也是采⽤==⽐较，通常会重写</p><ul><li><p>Objeect</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>String中，重写了object的equals方法，String类中被复写的equals()⽅法其实是⽐较两个字符串的内容。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> anotherString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul></li></ol><h3 id="hashcode-与equals-之间的关系" tabindex="-1"><a class="header-anchor" href="#hashcode-与equals-之间的关系" aria-hidden="true">#</a> hashCode()与equals()之间的关系？</h3><ol><li>hashCode() 的作⽤是获取哈希码，也称为散列码；它实际上是返回⼀个int整数。这个哈希码的作⽤是确定该对象在哈希表中的索引位置，hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有hashCode() 函数。</li><li>如果两个对象相等，则hashcode⼀定也是相同的。</li><li>两个对象相等,对两个对象分别调⽤equals⽅法都返回true。</li></ol><h3 id="final关键字的作用是什么" tabindex="-1"><a class="header-anchor" href="#final关键字的作用是什么" aria-hidden="true">#</a> final关键字的作⽤是什么？</h3><ol><li>修饰类：表示类不可被继承。</li><li>修饰⽅法：表示⽅法不可被⼦类覆盖，但是可以重载。</li><li>修饰变量：表示变量⼀旦被赋值就不可以更改它的值。</li><li>修饰基本类型数据和引⽤类型数据： <ul><li>如果是基本数据类型的变量，则其数值⼀旦在初始化之后便不能更改。</li><li>如果是引⽤类型的变量，则在对其初始化之后便不能再让其指向另⼀个对象。但是引⽤的值是可变的。</li></ul></li></ol><h3 id="为什么局部内部类和匿名内部类只能访问局部final变量" tabindex="-1"><a class="header-anchor" href="#为什么局部内部类和匿名内部类只能访问局部final变量" aria-hidden="true">#</a> 为什么局部内部类和匿名内部类只能访问局部final变量？</h3><ol><li>⾸先需要知道的⼀点是: 内部类和外部类是处于同⼀个级别的，内部类不会因为定义在⽅法中就会随着⽅法的执⾏完毕就被销毁。</li><li>当外部类的⽅法结束时，局部变量就会被销毁了，但是内部类对象可能还存在，这⾥就会产⽣问题：内部类对象访问了⼀个不存在的变量。为了解决这个问题，就将局部变量复制了⼀份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它。</li><li>将局部变量复制为内部类的成员变量时，必须保证这两个变量是⼀样的，也就是如果我们在内部类中修改了成员变量，⽅法中的局部变量也得跟着改变，怎么解决问题呢？ <ul><li>就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和⽅法的局部变量的⼀致性。这实际上也是⼀种妥协。使得局部变量与内部类内建⽴的拷⻉保持⼀致。</li></ul></li></ol><h3 id="string、stringbuffer、stringbuilder的区别" tabindex="-1"><a class="header-anchor" href="#string、stringbuffer、stringbuilder的区别" aria-hidden="true">#</a> String、StringBuffer、StringBuilder的区别?</h3><ol><li>String.intern()： <ul><li>调用它时，如果常量池中存在当前字符串, 就会直接返回当前字符串。</li><li>如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。</li></ul></li><li>String是不可变的，如果尝试去修改，会新⽣成⼀个字符串对象，StringBuffer和StringBuilder是可变的。</li><li>StringBuffer是线程安全的，StringBuilder是线程不安全的，所以在单线程环境下StringBuilder效率会更⾼。</li></ol><h3 id="重载和重写的区别" tabindex="-1"><a class="header-anchor" href="#重载和重写的区别" aria-hidden="true">#</a> 重载和重写的区别？</h3><ol><li>发⽣在同⼀个类中，⽅法名必须相同，参数类型不同、个数不同、顺序不同，⽅法返回值和访问修饰符可以不同，发⽣在编译时。</li><li>发⽣在⽗⼦类中，⽅法名、参数列表必须相同，返回值范围⼩于等于⽗类，抛出的异常范围⼩于等于⽗类，访问修饰符范围⼤于等于⽗类；如果⽗类⽅法访问修饰符为private则⼦类就不能重写该⽅法。</li></ol><h3 id="接口和抽象类的区别" tabindex="-1"><a class="header-anchor" href="#接口和抽象类的区别" aria-hidden="true">#</a> 接⼝和抽象类的区别？</h3><ol><li>抽象类可以存在普通成员函数，⽽接⼝中只能存在public abstract ⽅法。</li><li>抽象类中的成员变量可以是各种类型的，⽽接⼝中的成员变量只能是public static final类型的。</li><li>抽象类只能继承⼀个，接⼝可以实现多个。</li></ol><h3 id="list和set的区别" tabindex="-1"><a class="header-anchor" href="#list和set的区别" aria-hidden="true">#</a> List和Set的区别？</h3><ol><li>List：有序，按对象进⼊的顺序保存对象，可重复，允许多个Null元素对象，可以使⽤Iterator取出所有元素，在逐⼀遍历，还可以使⽤get(int index)获取指定下标的元素。</li><li>Set：⽆序，不可重复，最多允许有⼀个Null元素对象，取元素时只能⽤Iterator接⼝取得所有元素，在逐⼀遍历各个元素</li></ol><h3 id="arraylist和linkedlist区别" tabindex="-1"><a class="header-anchor" href="#arraylist和linkedlist区别" aria-hidden="true">#</a> ArrayList和LinkedList区别？</h3><ol><li>⾸先，他们的底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList底层是基于链表实现的。</li><li>由于底层数据结构不同，他们所适⽤的场景也不同，ArrayList更适合随机查找，LinkedList更适合删除和添加。查询、添加、删除的时间复杂度不同。</li><li>另外ArrayList和LinkedList都实现了List接⼝，但是LinkedList还额外实现了Deque接⼝，所以LinkedList还可以当做队列来使⽤。</li></ol><h3 id="hashmap和hashtable有什么区别-其底层实现是什么" tabindex="-1"><a class="header-anchor" href="#hashmap和hashtable有什么区别-其底层实现是什么" aria-hidden="true">#</a> HashMap和HashTable有什么区别？其底层实现是什么？</h3><ol><li>区别： <ul><li>HashMap⽅法没有synchronized修饰，线程⾮安全，HashTable线程安全。</li><li>HashMap允许key和value为null，⽽HashTable不允许（源码中有判断）。</li></ul></li><li>底层实现：数组+链表实现，jdk8开始链表⾼度到8、数组⻓度超过64，链表转变为红⿊树，元素以内部类Node节点存在。 <ul><li>计算key的hash值，⼆次hash然后对数组⻓度取模，对应到数组下标。</li><li>如果没有产⽣hash冲突(下标位置没有元素)，则直接创建Node存⼊数组。</li><li>如果产⽣hash冲突，先进⾏equal⽐较，相同则取代该元素，不同，则判断链表⾼度插⼊链表，链表⾼度达到8，并且数组⻓度到64则转变为红⿊树，⻓度低于6则将红⿊树转回链表。</li><li>key为null，存在下标0的位置。</li></ul></li></ol><h3 id="谈谈concurrenthashmap的扩容机制" tabindex="-1"><a class="header-anchor" href="#谈谈concurrenthashmap的扩容机制" aria-hidden="true">#</a> 谈谈ConcurrentHashMap的扩容机制？</h3><ol><li><p>JDK1.7</p><ul><li><p>1.7版本的ConcurrentHashMap是基于Segment分段实现的，每个Segment相对于⼀个⼩型的HashMap。</p></li><li><p>每个Segment内部会进⾏扩容，和HashMap的扩容逻辑类似，先⽣成新的数组，然后转移元素到新数组中。</p></li><li><p>扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值</p></li></ul></li><li><p>JDK1.8</p><ul><li>1.8版本的ConcurrentHashMap不再基于Segment实现。</li><li>ConcurrentHashMap是⽀持多个线程同时扩容的，当某个线程进⾏put时，如果发现ConcurrentHashMap正在进⾏扩容那么该线程⼀起进⾏扩容，如果发现没有正在进⾏扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进⾏扩容。</li></ul></li></ol><h3 id="jdk1-7到jdk1-8-hashmap-发生了什么变化" tabindex="-1"><a class="header-anchor" href="#jdk1-7到jdk1-8-hashmap-发生了什么变化" aria-hidden="true">#</a> Jdk<strong>1</strong>.<strong>7</strong>到Jdk<strong>1</strong>.<strong>8</strong> HashMap 发⽣了什么变化？</h3><ol><li>JDK1.7 <ul><li>HashMap 底层结构使用是数组+链表。</li><li>链表插⼊使⽤的是头插法。</li><li>判断扩容时：只要不小于阈值就直接扩容2倍。</li></ul></li><li>JDK1.8 <ul><li>HashMap 底层结构使用是数组+链表+红⿊树，加红⿊树的⽬的是提⾼HashMap插⼊和查询整体效率。</li><li>链表插⼊使⽤的是尾插法，因为1.8中插⼊key和value时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好就直接使⽤尾插法。</li><li>扩容策略会更优化，因为1.7中哈希算法比较复杂，存在各种右移与异或运算，1.8中进行了简化，因为复杂的哈希算法的目的就是提高散列性，来提高HashMap的整体效率，而1.8中新增了红黑树，所以可以适当简化哈希算法，节省CPU资源。</li></ul></li></ol><h3 id="hashmap的扩容机制原理" tabindex="-1"><a class="header-anchor" href="#hashmap的扩容机制原理" aria-hidden="true">#</a> HashMap的扩容机制原理？</h3><ol><li><p>JDK1.7</p><ul><li>先⽣成新数组。</li><li>遍历⽼数组中的每个位置上的链表上的每个元素。</li><li>取每个元素的key，并基于新数组⻓度，计算出每个元素在新数组中的下标。</li><li>将元素添加到新数组中去。</li><li>所有元素转移完了之后，将新数组赋值给HashMap对象的table属性。</li></ul></li><li><p>JDK1.8</p><ul><li>先⽣成新数组。</li><li>遍历⽼数组中的每个位置上的链表或红⿊树。 <ul><li>如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去。</li><li>如果是红⿊树，则先遍历红⿊树，先计算出红⿊树中每个元素对应在新数组中的下标位置。 <ul><li>统计每个下标位置的元素个数</li><li>如果该位置下的元素个数超过了8，则⽣成⼀个新的红⿊树，并将根节点的添加到新数组的对 应位置</li><li>如果该位置下的元素个数没有超过8，那么则⽣成⼀个链表，并将链表的头节点添加到新数组 的对应位置</li></ul></li></ul></li><li>所有元素转移完了之后，将新数组赋值给HashMap对象的table属性。</li></ul></li></ol><h3 id="泛型中extends和super的区别" tabindex="-1"><a class="header-anchor" href="#泛型中extends和super的区别" aria-hidden="true">#</a> 泛型中extends和super的区别？</h3><ol><li><code>&lt;? extends T&gt;</code>表示包括T在内的任何T的⼦类。</li><li><code>&lt;? super T&gt;</code>表示包括T在内的任何T的⽗类。</li></ol><h3 id="深拷⻉和浅拷⻉区别" tabindex="-1"><a class="header-anchor" href="#深拷⻉和浅拷⻉区别" aria-hidden="true">#</a> 深拷⻉和浅拷⻉区别？</h3><ol><li>深拷⻉和浅拷⻉就是指对象的拷⻉，⼀个对象中存在两种类型的属性，⼀种是基本数据类型，⼀种是实例对象的引⽤（引用数据类型）。</li><li>浅拷⻉是指，只会拷⻉基本数据类型的值，以及实例对象的引⽤地址，并不会复制⼀份引⽤地址所指向的对象。</li><li>深拷⻉是指，既会拷⻉基本数据类型的值，也会针对实例对象的引⽤地址所指向的对象进⾏复制，深拷⻉出来的对象，内部的属性指向的不是同⼀个对象。</li></ol><h3 id="copyonwritearraylist的底层原理是怎样的" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist的底层原理是怎样的" aria-hidden="true">#</a> CopyOnWriteArrayList的底层原理是怎样的？</h3><ol><li>⾸先CopyOnWriteArrayList内部也是⽤过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制⼀个新的数组，写操作在新数组上进⾏，读操作在原数组上进⾏。</li><li>并且，写操作会加锁，防⽌出现并发写⼊丢失数据的问题，写操作结束之后会把原数组指向新数组。</li><li>CopyOnWriteArrayList允许在写操作时来读取数据，⼤⼤提⾼了读的性能，因此适合读多写少的应⽤场景。</li><li>CopyOnWriteArrayList会⽐较占内存，同时可能读到的数据不是实时最新的数据，所以不适合实时性要求很⾼的场景。</li></ol><h3 id="java中的异常体系是怎样的" tabindex="-1"><a class="header-anchor" href="#java中的异常体系是怎样的" aria-hidden="true">#</a> Java中的异常体系是怎样的？</h3><ol><li>Java中的所有异常都来⾃顶级⽗类Throwable，Throwable下有两个⼦类Exception和Error。</li><li>Error是程序⽆法处理的错误，⼀旦出现这个错误，则程序将被迫停⽌运⾏。</li><li>Exception不会导致程序停⽌，⼜分为两个部分RunTimeException运⾏时异常和CheckedException检查异常。 <ul><li>RunTimeException常常发⽣在程序运⾏过程中，会导致程序当前线程执⾏失败。</li><li>CheckedException常常发⽣在程序编译过程中，会导致程序编译不通过。</li></ul></li></ol><h3 id="java中有哪些类加载器" tabindex="-1"><a class="header-anchor" href="#java中有哪些类加载器" aria-hidden="true">#</a> Java中有哪些类加载器？</h3><ol><li>JDK⾃带有三个类加载器：BootStrapClassLoader、ExtClassLoader、AppClassLoader。</li><li>BootStrapClassLoader是ExtClassLoader的⽗类加载器，默认负责加载<code>%JAVA_HOME%lib</code>⽂件夹下的jar包和class⽂件。</li><li>ExtClassLoader是AppClassLoader的⽗类加载器，负责加载<code>%JAVA_HOME%/lib/ext</code>⽂件夹下的jar包和class⽂件。</li><li>AppClassLoader是⾃定义类加载器的⽗类，负责加载<code>classpath</code>下的类⽂件。</li></ol><h3 id="说说类加载器双亲委派模型" tabindex="-1"><a class="header-anchor" href="#说说类加载器双亲委派模型" aria-hidden="true">#</a> 说说类加载器双亲委派模型？</h3><ol><li>JVM中存在三个默认的类加载器：BootStrapClassLoader、ExtClassLoader、AppClassLoader，AppClassLoader的⽗加载器是ExtClassLoader，ExtClassLoader的⽗加载器是BootstrapClassLoader。</li><li>JVM在加载⼀个类时 <ul><li>会先调⽤AppClassLoader的loadClass⽅法来加载这个类，不过在这个⽅法中，会先使⽤ExtClassLoader的loadClass⽅法来加载类。</li><li>同样ExtClassLoader的loadClass⽅法中会先使⽤BootstrapClassLoader来加载类，如果BootstrapClassLoader加载到了就直接成功。</li><li>如果BootstrapClassLoader没有加载到，那么ExtClassLoader就会⾃⼰尝试加载该类，如果没有加载到，那么则会由AppClassLoader来加载这个类。</li></ul></li><li>所以，双亲委派指得是，JVM在加载类时，会委派给Ext和Bootstrap进⾏加载，如果没加载到才由⾃⼰进⾏加载。</li></ol><h3 id="gc如何判断对象可以被回收" tabindex="-1"><a class="header-anchor" href="#gc如何判断对象可以被回收" aria-hidden="true">#</a> GC如何判断对象可以被回收？</h3><ol><li>引⽤计数法：每个对象有⼀个引⽤计数属性，新增⼀个引⽤时计数加1，引⽤释放时计数减1，计数为0时可以回收。引⽤计数法，可能会出现A 引⽤了 B，B ⼜引⽤了 A，这时候就算他们都不再使⽤了，但因为相互引⽤ 计数器=1 永远⽆法被回收。（造成循环依赖问题）。</li><li>可达性分析法： GC从 Roots根开始向下搜索，搜索所⾛过的路径称为引⽤链。当⼀个对象到 GC Roots 没有任何引⽤链相连时，则证明此对象是不可⽤的。</li></ol><h3 id="一个对象从加载到jvm-再到被gc清除-都经历了什么过程" tabindex="-1"><a class="header-anchor" href="#一个对象从加载到jvm-再到被gc清除-都经历了什么过程" aria-hidden="true">#</a> ⼀个对象从加载到JVM，再到被GC清除，都经历了什么过程？</h3><ol><li>.⽤户创建⼀个对象，JVM⾸先需要到⽅法区去找对象的类型信息。然后再创建对象，JVM要实例化⼀个对象，⾸先要在堆当中先创建⼀个对。</li><li>对象⾸先会分配在堆内存中新⽣代的Eden。然后经过⼀次Minor GC，对象如果存活，就会进⼊S区。在后续的每次GC中，如果对象⼀直存活，就会在S区来回拷⻉，每移动⼀次，年龄加1。年龄最⼤是15， 超过⼀定年龄后，对象转⼊⽼年代。</li><li>当⽅法执⾏结束后，栈中的指针会先移除掉。</li><li>堆中的对象，经过Full GC，就会被标记为垃圾，然后被GC线程清理掉。</li></ol><h3 id="jvm中哪些是线程共享区" tabindex="-1"><a class="header-anchor" href="#jvm中哪些是线程共享区" aria-hidden="true">#</a> JVM中哪些是线程共享区？</h3><ol><li><p>堆区和⽅法区是所有线程共享的，栈、本地⽅法栈、程序计数器是每个线程独有的。</p><p><img src="`+e+`" alt="image-20230604153726061"></p></li></ol><h3 id="线程的生命周期-线程有几种状态" tabindex="-1"><a class="header-anchor" href="#线程的生命周期-线程有几种状态" aria-hidden="true">#</a> 线程的⽣命周期？线程有⼏种状态？</h3><ol><li>线程通常有五种状态，创建，就绪，运⾏、阻塞和死亡状态。</li><li>新建状态（New）：新创建了⼀个线程对象。</li><li>就绪状态（Runnable）：线程对象创建后，其他线程调⽤了该对象的start⽅法。该状态的线程位于可运⾏线程池中，变得可运⾏，等待获取CPU的使⽤权。</li><li>运⾏状态（Running）：就绪状态的线程获取了CPU的使⽤权，执⾏程序代码。</li><li>阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使⽤权，暂时停⽌运⾏，阻塞的情况⼜分为三种： <ul><li>等待阻塞：运⾏的线程执⾏wait⽅法，该线程会释放占⽤的所有资源。JVM会把该线程放⼊“等待池”中。进⼊这个状态后，是不能⾃动唤醒的，必须依靠其他线程调⽤notify或notifyAll⽅法才能被唤醒，wait是object类的⽅法。</li><li>同步阻塞：运⾏的线程在获取对象的同步锁时，若该同步锁被别的线程占⽤，则JVM会把该线程放⼊“锁池”中。 <ul><li>锁池：所有需要竞争同步锁的线程都会放在锁池当中，⽐如当前对象的锁已经被其中⼀个线程得到，则其他线程需要在这个锁池进⾏等待。</li><li>等待池：当我们调⽤wait（）⽅法后，线程会放到等待池当中，等待池的线程是不会去竞争同步锁。</li></ul></li><li>其他阻塞：运⾏的线程执⾏sleep或join⽅法，JVM会把该线程置为阻塞状态，sleep是Thread类的⽅法。</li></ul></li><li>死亡状态（Dead）：线程执⾏完了或者因异常退出了run⽅法，该线程结束⽣命周期。、</li></ol><h3 id="sleep-、wait-、join-、yield-之间的的区别" tabindex="-1"><a class="header-anchor" href="#sleep-、wait-、join-、yield-之间的的区别" aria-hidden="true">#</a> sleep()、wait()、join()、yield()之间的的区别？</h3><ol><li>sleep 和yield是 Thread 类的静态本地⽅法、wait 则是 Object 类的本地⽅法、join是线程实例方法。</li><li>sleep⽅法不会释放lock，但是wait会释放，⽽且会加⼊到等待队列中。</li><li>sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别⼈中断），sleep 会让出 CPU 执⾏时间且强制上下⽂切换，⽽ wait 则不⼀定，wait 后可能还是有机会重新竞争到锁继续执⾏的。</li><li>yield（）执⾏后线程直接进⼊就绪状态，⻢上释放了cpu的执⾏权，但是依然保留了cpu的执⾏资格，所以有可能cpu下次进⾏线程调度还会让这个线程获取到执⾏权继续执⾏。</li><li>join（）执⾏后线程进⼊阻塞状态，例如在线程B中调⽤线程A的join（），那线程B会进⼊到阻塞队列，直到线程A结束或中断线程。</li></ol><h3 id="thread和runable的区别" tabindex="-1"><a class="header-anchor" href="#thread和runable的区别" aria-hidden="true">#</a> Thread和Runable的区别？</h3><ol><li>Thread和Runnable的实质是继承关系，没有可⽐性。⽆论使⽤Runnable还是Thread，底层都会newThread，然后执⾏run⽅法。</li><li>⽤法上，如果有复杂的线程操作需求，那就选择继承Thread，如果只是简单的执⾏⼀个任务，那就实现runnable。</li></ol><h3 id="对守护线程的理解" tabindex="-1"><a class="header-anchor" href="#对守护线程的理解" aria-hidden="true">#</a> 对守护线程的理解？</h3><ol><li>守护线程：为所有⾮守护线程提供服务的线程；任何⼀个守护线程都是整个JVM中所有⾮守护线程的保姆。</li><li>由于守护线程的终⽌是⾃身⽆法控制的（全部的非守护线程结束了，守护线程就自己中断结束），因此千万不要把IO、File等重要操作逻辑分配给它。</li><li>守护线程的作⽤，举个例子：GC垃圾回收线程就是⼀个经典的守护线程，当我们的程序中不再有任何运⾏的Thread时，程序就不会再产⽣垃圾，垃圾回收器也就⽆事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会⾃动离开。</li></ol><h3 id="threadlocal的底层原理" tabindex="-1"><a class="header-anchor" href="#threadlocal的底层原理" aria-hidden="true">#</a> ThreadLocal的底层原理？</h3><ol><li>. ThreadLocal是Java中所提供的线程本地存储机制，可以利⽤该机制将数据缓存在某个线程内部，该线程可以在任意时刻、任意⽅法中获取缓存的数据。</li><li>ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象（注意不是ThreadLocal对象）中都存在⼀个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值。</li><li>如果在线程池中使⽤ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使⽤完之后，应该要把设置的key，value，也就是Entry对象进⾏回收，但线程池中的线程不会回收。解决办法是，在使⽤了ThreadLocal对象之后，⼿动调⽤ThreadLocal的remove⽅法，⼿动清除Entry对象。</li></ol><h3 id="串行、并发、并行之间的区别" tabindex="-1"><a class="header-anchor" href="#串行、并发、并行之间的区别" aria-hidden="true">#</a> 串⾏、并发、并⾏之间的区别？</h3><ol><li>串⾏（排队执行）：在时间上不可能发⽣重叠，前⼀个任务没搞定，下⼀个任务就只能等着。</li><li>并⾏（一起执行）：在时间上是重叠的，两个任务在同⼀时刻互不⼲扰的同时执⾏。</li><li>并发（交替执行）：统⼀时间点，只有⼀个任务运⾏，交替执⾏，允许两个任务彼此⼲扰。</li></ol><h3 id="并发的三大特性" tabindex="-1"><a class="header-anchor" href="#并发的三大特性" aria-hidden="true">#</a> 并发的三⼤特性？</h3><ol><li><p>原⼦性：在⼀个操作中cpu不可以在中途暂停然后再调度，即不被中断操作，要么全部执⾏完成，要么都不执⾏。</p><ul><li><p>看一段代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    count<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 1、将 count 从主存读到⼯作内存中的副本中</span>
<span class="token comment">// 2、+1的运算</span>
<span class="token comment">// 3、将结果写⼊⼯作内存</span>
<span class="token comment">// 4、将⼯作内存的值刷回主存(什么时候刷⼊由操作系统决定，不确定的)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>那程序中原⼦性指的是最⼩的操作单元，⽐如⾃增操作，它本身其实并不是原⼦性操作，分了3步的，包括读取变量的原始值、进⾏加1操作、写⼊⼯作内存。所以在多线程中，有可能⼀个线程还没⾃增完，可能才执⾏到第⼆部，另⼀个线程就已经读取了值，导致结果错误。那如果我们能保证⾃增操作是⼀个原⼦性的操作，那么就能保证其他线程读取到的⼀定是⾃增后的数据。</p></li><li><p>关键字：synchronized</p></li></ul></li><li><p>可见性：当多个线程访问同⼀个变量时，⼀个线程修改了这个变量的值，其他线程能够⽴即看得到修改的值。</p><ul><li>若两个线程在不同的cpu，那么线程1改变了i的值还没刷新到主存，线程2⼜使⽤了i，那么这个i值肯定还是之前的，线程1对变量的修改线程没看到这就是可⻅性问题。</li><li>关键字：volatile、synchronized、final</li></ul></li><li><p>有序性：虚拟机在进⾏代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，虚拟机不⼀定会按照我们写的代码的顺序来执⾏，有可能将他们重排序。</p><ul><li>关键字：volatile、synchronized。</li></ul></li></ol><h3 id="java死锁如何避免" tabindex="-1"><a class="header-anchor" href="#java死锁如何避免" aria-hidden="true">#</a> Java死锁如何避免？</h3><ol><li>造成死锁的⼏个原因 <ul><li>⼀个资源每次只能被⼀个线程使⽤。</li><li>⼀个线程在阻塞等待某个资源时，不释放已占有资源。</li><li>⼀个线程已经获得的资源，在未使⽤完之前，不能被强⾏剥夺。</li></ul></li><li>在开发过程中如何避免死锁 <ul><li>要注意加锁顺序，保证每个线程按同样的顺序进⾏加锁。</li><li>要注意加锁时限，可以针对锁设置⼀个超时时间。</li><li>要注意死锁检查，这是⼀种预防机制，确保在第⼀时间发现死锁并进⾏解决。</li></ul></li></ol><h3 id="如何理解volatile关键字" tabindex="-1"><a class="header-anchor" href="#如何理解volatile关键字" aria-hidden="true">#</a> 如何理解volatile关键字？</h3><ol><li>volatile关键字：保证被volatile修饰的共享变量对所有线程总是可⻅的，也就是当⼀个线程修改了⼀个被volatile修饰共享变量的值，新值总是可以被其他线程⽴即得知。</li><li>使⽤volatile关键字会强制将修改的值⽴即写⼊主存。</li><li>volatile不能保证线程安全。</li></ol><h3 id="为什么用线程池-解释下线程池参数" tabindex="-1"><a class="header-anchor" href="#为什么用线程池-解释下线程池参数" aria-hidden="true">#</a> 为什么⽤线程池？解释下线程池参数？</h3><ol><li><p>使用线程池目的</p><ul><li>降低资源消耗：降低创建和销毁线程的带来的消耗，提⾼线程利⽤率。</li><li>提⾼响应速度：任务来了，直接有线程可⽤可执⾏，⽽不是先创建线程，再执⾏。</li><li>提⾼线程的可管理性：线程是稀缺资源，使⽤线程池可以统⼀分配调优监控。</li></ul></li><li><p>线程池参数</p><ul><li><p>corePoolSize：代表核⼼线程数。也就是正常情况下创建⼯作的线程数，这些线程创建后并不会消除，⽽是⼀种常驻线程。</p></li><li><p>maxinumPoolSize：是最⼤线程数。表示最⼤允许被创建的线程数，⽐如当前任务较多，将核⼼线程数都⽤完了，还⽆法满⾜需求时（任务队列也已经满了），此时就会创建新的线程，但是线程池内线程总数不会超过最⼤线程数。</p></li><li><p>keepAliveTime：表示超出核⼼线程数之外的线程的空闲存活时间。也就是核⼼线程不会消除，但是超出核⼼线程数的部分线程如果空闲⼀定的时间则会被消除。</p></li><li><p>workQueue：存放待执⾏的任务。假设我们现在核⼼线程都已被使⽤，还有任务进来则全部放⼊队列，直到整个队列被放满但任务还再持续进⼊则会开始创建新的线程。</p></li><li><p>ThreadFactory：线程⼯⼚，⽤来⽣产线程执⾏任务。我们可以选择使⽤默认的创建⼯⼚，产⽣的线程都在同⼀个组内，拥有相同的优先级，且都不是守护线程。当然我们也可以选择⾃定义线程⼯⼚，⼀般我们会根据业务来制定不同的线程⼯⼚。</p></li><li><p>Handler ：任务拒绝策略。</p><ul><li>任务被拒绝有两种情况： <ul><li>当我们调⽤ shutdown 等⽅法关闭线程池后，这时候即使线程池内部还有没执⾏完的任务正在执⾏，但是由于线程池已经关闭，我们再继续向线程池提交任务就会遭到拒绝。</li><li>是当达到最⼤线程数，线程池已经没有能⼒继续处理新提交的任务时也会遭到拒绝。</li></ul></li><li>任务拒绝策略： <ul><li>丢弃任务并抛出RejectedExecutionException异常（线程池默认的拒绝策略）。</li><li>丢弃队列最前面的任务，然后重新提交被拒绝的任务。</li><li>丢弃策略，什么都不做，即丢弃新提交的任务。</li><li>调用者运行策略，线程池中没办法运行，那么就由提交任务的这个线程运行。会使用调用线程池的Thread线程对象处理被拒绝的任务。</li></ul></li></ul></li></ul></li></ol><h3 id="线程池的底层工作原理" tabindex="-1"><a class="header-anchor" href="#线程池的底层工作原理" aria-hidden="true">#</a> 线程池的底层⼯作原理？</h3><ol><li>线程池内部是通过队列+线程实现的。</li><li>如果此时线程池中的线程数量⼩于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</li><li>如果此时线程池中的线程数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放⼊缓冲队列。</li><li>如果此时线程池中的线程数量⼤于等于corePoolSize，缓冲队列workQueue满，并且线程池中的数量⼩于maximumPoolSize，建新的线程来处理被添加的任务。</li><li>如果此时线程池中的线程数量⼤于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。</li><li>当线程池中的线程数量⼤于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终⽌。</li></ol><h3 id="线程池中阻塞队列的作用" tabindex="-1"><a class="header-anchor" href="#线程池中阻塞队列的作用" aria-hidden="true">#</a> 线程池中阻塞队列的作⽤？</h3><ol><li>⼀般的队列只能保证作为⼀个有限⻓度的缓冲区，如果超出了缓冲⻓度，就⽆法保留当前的任务了，阻塞队列通过阻塞可以保留住当前想要继续⼊队的任务。</li></ol><h3 id="线程池中线程复用原理" tabindex="-1"><a class="header-anchor" href="#线程池中线程复用原理" aria-hidden="true">#</a> 线程池中线程复⽤原理？</h3><ol><li>在线程池中，同⼀个线程可以从阻塞队列中不断获取新任务来执⾏。</li><li>其核⼼原理在于线程池对 Thread进⾏了封装，并不是每次执⾏任务都会调⽤ Thread.start() 来创建新线程，⽽是让每个线程去执⾏⼀个“循环任务”，在这个“循环任务”中不停检查是否有任务需要被执⾏，如果有则直接执⾏，也就是调⽤任务中的 run ⽅法，将 run ⽅法当成⼀个普通的⽅法执⾏，通过这种⽅式只使⽤固定的线程就将所有任务的 run ⽅法串联起来。</li></ol><h3 id="reentrantlock中的公平锁和非公平锁的底层实现" tabindex="-1"><a class="header-anchor" href="#reentrantlock中的公平锁和非公平锁的底层实现" aria-hidden="true">#</a> ReentrantLock中的公平锁和⾮公平锁的底层实现？</h3><ol><li>⾸先不管是公平锁和⾮公平锁，它们的底层实现都会使⽤AQS来进⾏排队，它们的区别在于线程在使⽤lock()⽅法加锁时： <ul><li>如果是公平锁，会先检查AQS队列中是否存在线程在排队，如果有线程在排队，则当前线程也进⾏排队。</li><li>如果是⾮公平锁，则不会去检查是否有线程在排队，⽽是直接竞争锁。</li></ul></li><li>不管是公平锁还是⾮公平锁，⼀旦没竞争到锁，都会进⾏排队，当锁释放时，都是唤醒排在最前⾯的线程，所以⾮公平锁只是体现在了线程加锁阶段，⽽没有体现在线程被唤醒阶段。</li><li>ReentrantLock是可重⼊锁，不管是公平锁还是⾮公平锁都是可重⼊的。</li></ol><h3 id="reentrantlock中trylock-和lock-方法的区别" tabindex="-1"><a class="header-anchor" href="#reentrantlock中trylock-和lock-方法的区别" aria-hidden="true">#</a> ReentrantLock中tryLock()和lock()⽅法的区别？</h3><ol><li>tryLock()表示尝试加锁，可能加到，也可能加不到，该⽅法不会阻塞线程，如果加到锁则返回true，没有加到则返回false。</li><li>lock()表示阻塞加锁，线程会阻塞直到加到锁，⽅法也没有返回值。</li></ol><h3 id="countdownlatch和semaphore的区别和底层原理" tabindex="-1"><a class="header-anchor" href="#countdownlatch和semaphore的区别和底层原理" aria-hidden="true">#</a> CountDownLatch和Semaphore的区别和底层原理？</h3><ol><li>CountDownLatch表示计数器，可以给CountDownLatch设置⼀个数字，⼀个线程调⽤CountDownLatch的await()将会阻塞，其他线程可以调⽤CountDownLatch的countDown()⽅法来对CountDownLatch中的数字减⼀，当数字被减成0后，所有await的线程都将被唤醒。</li><li>Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使⽤该信号量，通过acquire()来获取许可，如果没有许可可⽤则线程阻塞，并通过AQS来排队，可以通过release()⽅法来释放许可，当某个线程释放了某个许可后，会从AQS中正在排队的第⼀个线程开始依次唤醒，直到没有空闲许可。</li><li>底层原理： <ul><li>CountDownLatch：调⽤await()⽅法的线程会利⽤AQS排队，⼀旦数字被减为0，则会将AQS中排队的线程依次唤醒。</li><li>Semaphore：当没有可以的许时会利⽤AQS排队，当有许可之后则会将AQS中排队的线程依次唤醒。</li></ul></li></ol><h3 id="sychronized的偏向锁、轻量级锁、重量级锁" tabindex="-1"><a class="header-anchor" href="#sychronized的偏向锁、轻量级锁、重量级锁" aria-hidden="true">#</a> Sychronized的偏向锁、轻量级锁、重量级锁？</h3><ol><li>偏向锁：在锁对象的对象头中记录⼀下当前获取到该锁的线程ID，该线程下次如果⼜来获取该锁就可以直接获取到了。</li><li>轻量级锁：由偏向锁升级⽽来，当⼀个线程获取到锁后，此时这把锁是偏向锁，此时如果有第⼆个线程来竞争锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁，是为了和重量级锁区分开来，轻量级锁底层是通过⾃旋来实现的，并不会阻塞线程。</li><li>重量级锁：如果⾃旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞。</li></ol><h3 id="对自旋锁的理解" tabindex="-1"><a class="header-anchor" href="#对自旋锁的理解" aria-hidden="true">#</a> 对自旋锁的理解？</h3><ol><li>⾃旋锁就是线程在获取锁的过程中，不会去阻塞线程。</li><li>⾃旋锁是线程通过CAS获取预期的⼀个标记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，整个运行过程中相对⽽⾔没有使⽤太多的操作系统资源，⽐较轻量。</li></ol><h3 id="sychronized和reentrantlock的区别" tabindex="-1"><a class="header-anchor" href="#sychronized和reentrantlock的区别" aria-hidden="true">#</a> Sychronized和ReentrantLock的区别？</h3><ol><li>sychronized是⼀个关键字，ReentrantLock是⼀个类。</li><li>sychronized会⾃动的加锁与释放锁，ReentrantLock需要程序员⼿动加锁与释放锁。</li><li>sychronized的底层是JVM层⾯的锁，ReentrantLock是API层⾯的锁。</li><li>. sychronized是⾮公平锁，ReentrantLock可以选择公平锁或⾮公平锁。</li><li>sychronized底层有⼀个锁升级的过程。</li></ol><h3 id="谈谈你对aqs的理解-aqs如何实现可重入锁" tabindex="-1"><a class="header-anchor" href="#谈谈你对aqs的理解-aqs如何实现可重入锁" aria-hidden="true">#</a> 谈谈你对AQS的理解，AQS如何实现可重⼊锁？</h3><ol><li>AQS是⼀个JAVA线程同步的框架，是JDK中很多锁⼯具的核⼼实现框架。</li><li>在AQS中，维护了⼀个信号量state和⼀个线程组成的双向链表队列。其中，这个线程队列，就是⽤来给线程排队的，⽽state就像是⼀个红绿灯，⽤来控制线程排队或者放⾏的。 在不同的场景下，有不⽤的意义。</li><li>在可重⼊锁这个场景下，state就⽤来表示加锁的次数。0标识⽆锁，每加⼀次锁，state就加1。释放锁state就减1。</li></ol><h3 id="悲观锁和乐观锁区别" tabindex="-1"><a class="header-anchor" href="#悲观锁和乐观锁区别" aria-hidden="true">#</a> 悲观锁和乐观锁区别？</h3><ol><li>悲观锁：共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。 <ul><li>顾名思义，就是比较悲观的锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</li><li>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li><li>Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</li></ul></li><li>乐观锁：乐观锁适用于多读的应用类型，这样可以提高吞吐量。 <ul><li>乐观锁和悲观锁相反，总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制或者CAS算法实现。</li></ul></li></ol><h3 id="对cas算法的理解" tabindex="-1"><a class="header-anchor" href="#对cas算法的理解" aria-hidden="true">#</a> 对CAS算法的理解？</h3><ol><li>CAS（compare and swap）比较和交换，是一种有名的无锁算法，能够在线程不被阻塞的情况下实现变量同步，所以也叫非阻塞同步。</li><li>CAS算法涉及三个操作数： <ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li></ul></li><li>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</li></ol><h3 id="如何解决乐观锁的aba问题" tabindex="-1"><a class="header-anchor" href="#如何解决乐观锁的aba问题" aria-hidden="true">#</a> 如何解决乐观锁的ABA问题 ？</h3><ol><li>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？</li><li>很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的ABA问题。</li><li>解决ABA最简单的方案：就是给值加一个修改版本号，每次值变化，都会修改它版本号，CAS操作时都对比此版本号。</li></ol>`,91),o=[t];function r(c,d){return l(),i("div",null,o)}const h=a(s,[["render",r],["__file","javase.html.vue"]]);export{h as default};
