import{_ as e,p as a,q as i,a1 as l}from"./framework-96b046e1.js";const n={},d=l(`<h1 id="maven" tabindex="-1"><a class="header-anchor" href="#maven" aria-hidden="true">#</a> Maven</h1><h3 id="maven-是什么" tabindex="-1"><a class="header-anchor" href="#maven-是什么" aria-hidden="true">#</a> maven 是什么？</h3><ol><li>Maven是一个项目管理工具，它包含了一个项目对象模型(pom)，一个项目生命周期(命令)，一个依赖管理系统(坐标)。</li></ol><h3 id="maven仓库分为几种" tabindex="-1"><a class="header-anchor" href="#maven仓库分为几种" aria-hidden="true">#</a> maven仓库分为几种？</h3><ol><li>本地仓库</li><li>远程仓库 <ul><li>中央仓库</li><li>私服</li><li>其他公共库</li></ul></li></ol><h3 id="什么是私服" tabindex="-1"><a class="header-anchor" href="#什么是私服" aria-hidden="true">#</a> 什么是私服？</h3><ol><li>私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的 Maven 用户使用。当 Maven 需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为 Maven 的下载请求提供服务。我们还可以把一些无法从外部仓库下载到的构件上传到私服上。</li></ol><h3 id="maven的生命周期有哪些" tabindex="-1"><a class="header-anchor" href="#maven的生命周期有哪些" aria-hidden="true">#</a> Maven的生命周期有哪些？</h3><ol><li>clean 移除所有上一次构建生成的文件</li><li>validate：验证工程是否正确，所有需要的资源是否可用</li><li>compile：编译项目的源代码</li><li>test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。</li><li>package：把已编译的代码打包成可发布的格式，比如 jar、war 等。</li><li>verify：运行所有检查，验证包是否有效且达到质量标准。</li><li>install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用</li><li>site 生成项目的站点文档</li><li>deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享</li></ol><h3 id="maven-坐标的含义" tabindex="-1"><a class="header-anchor" href="#maven-坐标的含义" aria-hidden="true">#</a> Maven 坐标的含义</h3><ol><li>groupId ：组织ID，定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.qjk）</li><li>artifactId ：项目ID，定义当前Maven项目名称（通常是模块名称，例如 order-service、goods-service）</li><li>version ：定义当前项目版本号</li><li>packaging ：定义 Maven 项目打包的方式，如没有 packaging ，则默认为 jar 包。</li><li>classifier ：该元素用来帮助定义构建输出的一些附件。附属构件与主构件对应。</li></ol><h3 id="scope依赖范围" tabindex="-1"><a class="header-anchor" href="#scope依赖范围" aria-hidden="true">#</a> scope依赖范围</h3><ol><li>compile：默认的scope，运行期有效，需要打入包中。</li><li>provided：编译期有效，运行期不需要提供，不会打入包中。</li><li>runtime：编译不需要，在运行期有效，需要导入包中。（接口与实现分离）</li><li>test：测试需要，不会打入包中。</li><li>system：非本地仓库引入、存在系统的某个路径下的jar。（一般不使用）。</li></ol><h3 id="如何排除依赖" tabindex="-1"><a class="header-anchor" href="#如何排除依赖" aria-hidden="true">#</a> 如何排除依赖</h3><ol><li><p>通过 <em>exclusions</em> 标签实现。</p></li><li><p>通过<em>optional</em>实现。</p></li></ol><h3 id="依赖传递原则" tabindex="-1"><a class="header-anchor" href="#依赖传递原则" aria-hidden="true">#</a> 依赖传递原则</h3><ol><li><p>最短路径原则</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a-&gt;b-&gt;c(2.0)
a-&gt;c(1.0)
最后采取 c(1.0) 这个版本，因为它短啊。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>最先声明原则</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a-&gt;b-&gt;c(2.0)
a-&gt;d-&gt;c(1.0)
因为b先声明引入了c，所以采取c(2.0)
当然如果我们在 a 中直接依赖了 c 肯定是以我们 a 的项目依赖的 c 版本为主，近亲原则
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol>`,17),r=[d];function s(c,t){return a(),i("div",null,r)}const h=e(n,[["render",s],["__file","maven.html.vue"]]);export{h as default};
